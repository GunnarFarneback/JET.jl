<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>README · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>README</a></li><li><a class="tocitem" href="config/">JET Configurations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>README</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>README</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JET-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations"><a class="docs-heading-anchor" href="#JET-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations">JET – experimental type checker for Julia, no need for additional type annotations</a><a id="JET-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#JET-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JET" href="#JET"><code>JET</code></a> — <span class="docstring-category">Module</span></header><section><div><p><img src="https://github.com/aviatesk/JET.jl/workflows/CI/badge.svg" alt="CI"/> <a href="https://codecov.io/gh/aviatesk/JET.jl"><img src="https://codecov.io/gh/aviatesk/JET.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><p><strong>behind the moar for performance ...</strong></p><p>JET.jl employs Julia&#39;s type inference for bug reports.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>JET.jl needs Julia versions 1.6 and higher; as such I recommend you give a try on this package with <a href="https://julialang.org/downloads/nightlies/">using nightly version</a> or <a href="https://github.com/JuliaLang/julia">building Julia from source</a>.</p></div></div><p><strong>demo</strong></p><p>Say you have this strange and buggy file and want to know where to fix:</p><blockquote><p>demo.jl</p></blockquote><pre><code class="language-julia"># demo
# ====

# fibonacci
# ---------

fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)

fib(1000)   # never terminates in ordinal execution
fib(m)      # undef var
fib(&quot;1000&quot;) # obvious type error


# language features
# -----------------

# user-defined types
struct Ty{T}
    fld::T
end

function foo(a)
    v = Ty(a)
    return bar(v)
end

# macros will be expanded
@inline bar(n::T)     where {T&lt;:Number} = n &lt; 0 ? zero(T) : one(T)
@inline bar(v::Ty{T}) where {T&lt;:Number} = bar(v.fdl) # typo &quot;fdl&quot;
@inline bar(v::Ty)                      = bar(convert(Number, v.fld))

foo(1.2)
foo(&quot;1&quot;) # `String` can&#39;t be converted to `Number`</code></pre><p>You can have JET.jl detect possible errors:</p><pre><code class="language-julia">julia&gt; using JET

julia&gt; profile_and_watch_file(&quot;demo.jl&quot;; annotate_types = true)

profiling from demo.jl (finished in 6.198 sec)
═════ 4 possible errors found ═════
┌ @ demo.jl:11 fib(m)
│ variable m is not defined: fib(m)
└──────────────
┌ @ demo.jl:12 fib(&quot;1000&quot;)
│┌ @ demo.jl:8 ≤(n::String, 2)
││┌ @ operators.jl:328 Base.&lt;(x::String, y::Int64)
│││┌ @ operators.jl:279 Base.isless(x::String, y::Int64)
││││ no matching method found for call signature: Base.isless(x::String, y::Int64)
│││└────────────────────
┌ @ demo.jl:33 foo(1.2)
│┌ @ demo.jl:25 bar(v::Ty{Float64})
││┌ @ demo.jl:30 Base.getproperty(v::Ty{Float64}, :fdl::Symbol)
│││┌ @ Base.jl:33 Base.getfield(x::Ty{Float64}, f::Symbol)
││││ type Ty{Float64} has no field fdl: Base.getfield(x::Ty{Float64}, f::Symbol)
│││└──────────────
┌ @ demo.jl:34 foo(&quot;1&quot;)
│┌ @ demo.jl:25 bar(v::Ty{String})
││┌ @ demo.jl:31 convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)
│││ no matching method found for call signature: convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)
││└──────────────</code></pre><p>Hooray ! JET.jl found possible error points (e.g. <code>MethodError: no method matching isless(::String, ::Int64)</code>) given toplevel call signatures of generic functions (e.g. <code>fib(&quot;1000&quot;)</code>).</p><p>Note that JET can find these errors while demo.jl is so inefficient (especially the <code>fib</code> implementation) that it would never terminate in actual execution. That is possible because JET analyzes code only on <em>type level</em>. This technique is often called &quot;abstract interpretation&quot; and JET internally uses Julia&#39;s native type inference implementation, so it can analyze code as fast/correctly as Julia&#39;s code generation.</p><p>Lastly let&#39;s apply the following diff to demo.jl so that it works nicely:</p><blockquote><p>fix-demo.jl.diff</p></blockquote><pre><code class="language-diff">diff --git a/demo.jl b/demo-fixed.jl
index d2b188a..1d1b3da 100644
--- a/demo.jl
+++ b/demo.jl
@@ -5,11 +5,21 @@
 # fibonacci
 # ---------

-fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)
+# cache, cache, cache
+function fib(n::T) where {T&lt;:Number}
+    cache = Dict(zero(T)=&gt;zero(T), one(T)=&gt;one(T))
+    return _fib(n, cache)
+end
+_fib(n, cache) = if haskey(cache, n)
+    cache[n]
+else
+    cache[n] = _fib(n-1, cache) + _fib(n-2, cache)
+end

-fib(1000)   # never terminates in ordinal execution
-fib(m)      # undef var
-fib(&quot;1000&quot;) # obvious type error
+fib(BigInt(1000)) # will terminate in ordinal execution as well
+m = 1000          # define m
+fib(m)
+fib(parse(Int, &quot;1000&quot;))


 # language features
@@ -27,8 +37,8 @@ end

 # macros will be expanded
 @inline bar(n::T)     where {T&lt;:Number} = n &lt; 0 ? zero(T) : one(T)
-@inline bar(v::Ty{T}) where {T&lt;:Number} = bar(v.fdl) # typo &quot;fdl&quot;
+@inline bar(v::Ty{T}) where {T&lt;:Number} = bar(v.fld) # typo fixed
 @inline bar(v::Ty)                      = bar(convert(Number, v.fld))

 foo(1.2)
-foo(&quot;1&quot;) # `String` can&#39;t be converted to `Number`
+foo(&#39;1&#39;) # `Char` will be converted to `UInt32`</code></pre><p>If you apply the diff (i.e. update and save the demo.jl), JET will automatically re-trigger profiling, and this time, won&#39;t complain anything:</p><blockquote><p>git apply fix-demo.jl.diff</p></blockquote><pre><code class="language-julia">profiling from demo.jl (finished in 0.317 sec)
No errors !</code></pre><p><strong>TODOs</strong></p><ul><li>documentation: WIP at <a href="https://github.com/aviatesk/JET.jl/pull/127">https://github.com/aviatesk/JET.jl/pull/127</a></li><li>release: see <a href="https://github.com/aviatesk/JET.jl/issues/121">https://github.com/aviatesk/JET.jl/issues/121</a></li><li>remove <code>Core.eval(CC, ...)</code> monkey patches (<a href="https://github.com/JuliaLang/julia/pull/39439">https://github.com/JuliaLang/julia/pull/39439</a>, <a href="https://github.com/JuliaLang/julia/pull/39305">https://github.com/JuliaLang/julia/pull/39305</a>, see also &quot;developer note&quot; section)</li><li>more accurate error reports in general<ul><li>enable constant propagation on union-split signatures (<a href="https://github.com/JuliaLang/julia/pull/39305">https://github.com/JuliaLang/julia/pull/39305</a>)</li></ul></li><li>provide editor/IDE integrations for &quot;watch&quot; mode (<a href="https://github.com/aviatesk/JET.jl/pull/85">https://github.com/aviatesk/JET.jl/pull/85</a> will be a starting point)</li><li>support package profiling (issue <a href="https://github.com/aviatesk/JET.jl/issues/76">https://github.com/aviatesk/JET.jl/issues/76</a>, something like PR <a href="https://github.com/aviatesk/JET.jl/pull/101">https://github.com/aviatesk/JET.jl/pull/101</a> can be a starting point)</li><li>implement a &quot;global&quot; version of type inference algorithm (see <a href="https://github.com/aviatesk/JET.jl/blob/80fd0d9586a01dda7e460ccd71d3d9f33189d4ba/src/abstractinterpretation.jl#L517-L523">this comment</a>)</li><li>performance linting (report performance pitfalls, i.e. report an error when there&#39;re too many methods matched)</li><li>ideally, I want to extend JET.jl to provide some of LSPs other than diagnostics, e.g. providers of completions, rename refactor, etc.</li></ul><p><strong>developer note</strong></p><p>JET.jl overloads functions from Juila&#39;s <code>Core.Compiler</code> module, which are intended for its native JIT type inference.</p><p>They&#39;re overloaded on <code>JETInterpreter</code> so that <code>typeinf(::JETInterpreter, ::InferenceState)</code> will do abstract interpretation tuned for JET.jl&#39;s type error analysis. Most overloads are done by using <code>invoke</code>, which allows us to call down to and reuse the original <code>NativeInterpreter</code>&#39;s abstract interpretation methods while passing <code>JETInterpreter</code> for subsequent (maybe overloaded) callees (see <code>@invoke</code> macro).</p><p>But sometimes we can&#39;t just use <code>@invoke</code> and have to change/discard some logics that are hard-coded within original native function. In such cases, currently JET.jl copy-and-pasted the original body of the overloaded function and applies monkey patches. I&#39;m planning to remove those monkey patches by adding some tweaks to Julia&#39;s compiler code itself, but for now, in order to keep the least maintainability, we do:</p><ul><li>use syntactic hacks (<code>#=== ... ===#</code>) to indicate the locations and purposes of each patch</li><li>each overload is directly evaluated in the <code>Core.Compiler</code> module so that we don&#39;t need to maintain miscellaneous imports</li><li>as such, the overloads are done within <code>__init__</code> hook; there are wrapper functions whose name starts with <code>overload_</code>  for each overloading and the wrappers are registered to <code>push_inithook!</code></li><li>the docstrings of the wrappers tell the purposes of each overload</li></ul><p><strong>acknowledgement</strong></p><p>This project started as my grad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by <a href="https://github.com/ruby/typeprof">ruby/typeprof</a>, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at <a href="https://github.com/aviatesk/grad-thesis">https://github.com/aviatesk/grad-thesis</a>, but currently it&#39;s only available in Japanese.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/617bf3ebfffc49e9b9f2fb2565cf086e637d0349/src/JET.jl#L1-L188">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="config/">JET Configurations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 March 2021 15:04">Tuesday 9 March 2021</span>. Using Julia version 1.7.0-DEV.673.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
