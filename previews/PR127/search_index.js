var documenterSearchIndex = {"docs":
[{"location":"#JET-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations","page":"README","title":"JET – experimental type checker for Julia, no need for additional type annotations","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET","category":"page"},{"location":"#JET","page":"README","title":"JET","text":"(Image: CI) (Image: codecov)\n\nbehind the moar for performance ...\n\nJET.jl employs Julia's type inference for bug reports.\n\nnote: Note\nJET.jl needs Julia versions 1.6 and higher; as such I recommend you give a try on this package with using nightly version or building Julia from source. \nAlso note that JET deeply relies on the type inference routine implemented in Julia's compiler, and so JET analysis result can vary depending on your Julia version. In general, the newer your Julia version is, your can expect JET to analyze your code more accurately and quickly, because Julia's compiler is rapidly-advancing, literally day by day.\n\ndemo\n\nSay you have this strange and buggy file and want to know where to fix:\n\ndemo.jl\n\n# demo\n# ====\n\n# fibonacci\n# ---------\n\nfib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n\nfib(1000)   # never terminates in ordinal execution\nfib(m)      # undef var\nfib(\"1000\") # obvious type error\n\n\n# language features\n# -----------------\n\n# user-defined types\nstruct Ty{T}\n    fld::T\nend\n\nfunction foo(a)\n    v = Ty(a)\n    return bar(v)\nend\n\n# macros will be expanded\n@inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n@inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\nfoo(1.2)\nfoo(\"1\") # `String` can't be converted to `Number`\n\nYou can have JET.jl detect possible errors:\n\njulia> using JET\n\njulia> profile_and_watch_file(\"demo.jl\"; annotate_types = true)\n\nprofiling from demo.jl (finished in 6.198 sec)\n═════ 4 possible errors found ═════\n┌ @ demo.jl:11 fib(m)\n│ variable m is not defined: fib(m)\n└──────────────\n┌ @ demo.jl:12 fib(\"1000\")\n│┌ @ demo.jl:8 ≤(n::String, 2)\n││┌ @ operators.jl:328 Base.<(x::String, y::Int64)\n│││┌ @ operators.jl:279 Base.isless(x::String, y::Int64)\n││││ no matching method found for call signature: Base.isless(x::String, y::Int64)\n│││└────────────────────\n┌ @ demo.jl:33 foo(1.2)\n│┌ @ demo.jl:25 bar(v::Ty{Float64})\n││┌ @ demo.jl:30 Base.getproperty(v::Ty{Float64}, :fdl::Symbol)\n│││┌ @ Base.jl:33 Base.getfield(x::Ty{Float64}, f::Symbol)\n││││ type Ty{Float64} has no field fdl: Base.getfield(x::Ty{Float64}, f::Symbol)\n│││└──────────────\n┌ @ demo.jl:34 foo(\"1\")\n│┌ @ demo.jl:25 bar(v::Ty{String})\n││┌ @ demo.jl:31 convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n│││ no matching method found for call signature: convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n││└──────────────\n\nHooray ! JET.jl found possible error points (e.g. MethodError: no method matching isless(::String, ::Int64)) given toplevel call signatures of generic functions (e.g. fib(\"1000\")).\n\nNote that JET can find these errors while demo.jl is so inefficient (especially the fib implementation) that it would never terminate in actual execution. That is possible because JET analyzes code only on type level. This technique is often called \"abstract interpretation\" and JET internally uses Julia's native type inference implementation, so it can analyze code as fast/correctly as Julia's code generation.\n\nLastly let's apply the following diff to demo.jl so that it works nicely:\n\nfix-demo.jl.diff\n\ndiff --git a/demo.jl b/demo-fixed.jl\nindex d2b188a..1d1b3da 100644\n--- a/demo.jl\n+++ b/demo.jl\n@@ -5,11 +5,21 @@\n # fibonacci\n # ---------\n\n-fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n+# cache, cache, cache\n+function fib(n::T) where {T<:Number}\n+    cache = Dict(zero(T)=>zero(T), one(T)=>one(T))\n+    return _fib(n, cache)\n+end\n+_fib(n, cache) = if haskey(cache, n)\n+    cache[n]\n+else\n+    cache[n] = _fib(n-1, cache) + _fib(n-2, cache)\n+end\n\n-fib(1000)   # never terminates in ordinal execution\n-fib(m)      # undef var\n-fib(\"1000\") # obvious type error\n+fib(BigInt(1000)) # will terminate in ordinal execution as well\n+m = 1000          # define m\n+fib(m)\n+fib(parse(Int, \"1000\"))\n\n\n # language features\n@@ -27,8 +37,8 @@ end\n\n # macros will be expanded\n @inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n-@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n+@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fld) # typo fixed\n @inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\n foo(1.2)\n-foo(\"1\") # `String` can't be converted to `Number`\n+foo('1') # `Char` will be converted to `UInt32`\n\nIf you apply the diff (i.e. update and save the demo.jl), JET will automatically re-trigger profiling, and this time, won't complain anything:\n\ngit apply fix-demo.jl.diff\n\nprofiling from demo.jl (finished in 0.317 sec)\nNo errors !\n\nTODOs\n\ndocumentation: WIP at https://github.com/aviatesk/JET.jl/pull/127\nrelease: see https://github.com/aviatesk/JET.jl/issues/121\nremove Core.eval(CC, ...) monkey patches (https://github.com/JuliaLang/julia/pull/39439, https://github.com/JuliaLang/julia/pull/39305, see also \"developer note\" section)\nmore accurate error reports in general\nenable constant propagation on union-split signatures (https://github.com/JuliaLang/julia/pull/39305)\nprovide editor/IDE integrations for \"watch\" mode (https://github.com/aviatesk/JET.jl/pull/85 will be a starting point)\nsupport package profiling (issue https://github.com/aviatesk/JET.jl/issues/76, something like PR https://github.com/aviatesk/JET.jl/pull/101 can be a starting point)\nimplement a \"global\" version of type inference algorithm (see this comment)\nperformance linting (report performance pitfalls, i.e. report an error when there're too many methods matched)\nideally, I want to extend JET.jl to provide some of LSPs other than diagnostics, e.g. providers of completions, rename refactor, etc.\n\ndeveloper note\n\nJET.jl overloads functions from Juila's Core.Compiler module, which are intended for its native JIT type inference.\n\nThey're overloaded on JETInterpreter so that typeinf(::JETInterpreter, ::InferenceState) will do abstract interpretation tuned for JET.jl's type error analysis. Most overloads are done by using invoke, which allows us to call down to and reuse the original NativeInterpreter's abstract interpretation methods while passing JETInterpreter for subsequent (maybe overloaded) callees (see @invoke macro).\n\nBut sometimes we can't just use @invoke and have to change/discard some logics that are hard-coded within original native function. In such cases, currently JET.jl copy-and-pasted the original body of the overloaded function and applies monkey patches. I'm planning to remove those monkey patches by adding some tweaks to Julia's compiler code itself, but for now, in order to keep the least maintainability, we do:\n\nuse syntactic hacks (#=== ... ===#) to indicate the locations and purposes of each patch\neach overload is directly evaluated in the Core.Compiler module so that we don't need to maintain miscellaneous imports\nas such, the overloads are done within __init__ hook; there are wrapper functions whose name starts with overload_  for each overloading and the wrappers are registered to push_inithook!\nthe docstrings of the wrappers tell the purposes of each overload\n\nacknowledgement\n\nThis project started as my grad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by ruby/typeprof, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at https://github.com/aviatesk/grad-thesis, but currently it's only available in Japanese.\n\n\n\n\n\n","category":"module"},{"location":"config/#JET-Configurations","page":"JET Configurations","title":"JET Configurations","text":"","category":"section"},{"location":"config/","page":"JET Configurations","title":"JET Configurations","text":"JET.JETAnalysisParams\nJET.JETInferenceParams\nJET.PrintConfig\nJET.JETLogger","category":"page"},{"location":"config/#JET.JETAnalysisParams","page":"JET Configurations","title":"JET.JETAnalysisParams","text":"Configurations for JET analysis\n\n\n\nstrict_condition_check::Bool = false \nEnables strict condition check. JET reports an error if a condition expression type is \"non-boolean\". In a case when   the condition type is Union, JET will report if either of union split case is   non-boolean type, but this can lead to lots of false positive error reports when the   code is not well-typed, because Julia Base defines generic functions that are commonly   used at a conditional context but also may return \"non-boolean\" values, e.g.:\n!(::Function) -> Function\n!(::Missing) -> Missing\n==(::Missing, ::Any) -> Missing\n==(::Any, ::Missing) -> Missing\nand thus loosely-typed conditional expression often becomes e.g. Union{Bool, Missing},   and consequently JET will report it as \"non-boolean\" type   (NOTE: in Julia Missing is certainly not valid conditional type). If this configuration is set to false, JET enables an heuristic to avoid those false   positive error reports and won't report an error if a condition expression type is   Union and either of its union split case is Function or Missing.\nThe effect of this configuration can be described with the following example:\nwith strict_condition_check::Bool = false (default)\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call test_f()\nNo errors !\nDict{Any, Int64}\nwith strict_condition_check::Bool = true\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call strict_condition_check = true test_f()\n═════ 1 possible error found ═════\n┌ @ REPL[2]:1 Main.Dict(Main.=>('a', 1), Main.=>(:b, 2))\n│┌ @ dict.jl:125 Base.Dict(ps)\n││┌ @ dict.jl:129 Base.dict_with_eltype(#308, kv, Base.eltype(kv))\n│││┌ @ abstractdict.jl:539 Base.grow_to!(Base.dict_with_eltype(DT_apply, _5), kv)\n││││┌ @ dict.jl:145 Base.grow_to!(dest2, itr, st)\n│││││┌ @ dict.jl:159 Base.setindex!(new, v, k)\n││││││┌ @ dict.jl:383 Base.ht_keyindex2!(h, key)\n│││││││┌ @ dict.jl:328 goto %35 if not Base.isequal(key, Base.getindex(keys, index))\n││││││││ for 1 of union split cases, non-boolean (Missing) used in boolean context: goto %35 if not Base.isequal(key::Symbol, Base.getindex(keys::Vector{Any}, index::Int64)::Any)::Union{Missing, Bool}\n│││││││└───────────────\nDict{Any, Int64}\n\n\n\nignore_native_remarks::Bool = true \nIf true, JET won't construct nor cache reports of \"native remarks\", which may speed up analysis time. \"Native remarks\" are information that Julia's native compiler emits about how type inference routine goes, and those remarks are less interesting in term of \"error checking\", so JET ignores them by default.\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.JETInferenceParams","page":"JET Configurations","title":"JET.JETInferenceParams","text":"Configurations for Julia's native type inference routine\n\n\n\nipo_constant_propagation::Bool = true \nEnables constant propagation in abstract interpretation. It is highly recommended that you keep this configuration true to get reasonable analysis, because constant propagation can cut off lots of false positive errorenous code paths and thus lead to more accurate and useful analysis results.\n\n\n\naggressive_constant_propagation::Bool = true \nIf true, JET will try to do constant propagation more \"aggressively\". As explained above, it can lead to more accurate analysis, but also lead to worse analysis performance at the cost of that.\n\n\n\nunoptimize_throw_blocks::Bool = false \nTurn this on to skip analysis on code blocks that will eventually lead to a throw call. This configuration may improve the analysis performance, but it's better to be turned off   for JET analysis, because there may be other errors even in those code blocks.\n\n\n\nnote: Note\nYou can also specify all the other parameters that Core.Compiler.InferenceParams can accept, e.g. max_methods::Int = 3, union_splitting::Int = 4, etc.\n\n\n\n\n\n","category":"function"},{"location":"config/#JET.PrintConfig","page":"JET Configurations","title":"JET.PrintConfig","text":"JET configurations for error printing\n\n\n\nprint_toplevel_success::Bool = false \nIf true, prints a message when there is no toplevel errors found.\n\n\n\nprint_inference_sucess::Bool = true \nIf true, print a message when there is no errors found in abstract interpretation based analysis pass.\n\n\n\nannotate_types::Bool = false \nWhen set to true, annotates types when printing analyzed call stack. Here are examples:\nDefault (no annotations):\njulia> @report_call sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()), #self#, a)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()), #self#, f, a)\n│││┌ @ reduce.jl:503 Base.mapreduce(f, Base.add_sum, a)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f, op, itr)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue(), #self#, f, op, itr)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f, op, init, itr)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′, nt, itr′)\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op, nt, itr)\n││││││││││┌ @ reduce.jl:62 op(v, Base.getindex(y, 1))\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op, :rf)(acc, x)\n││││││││││││┌ @ reduce.jl:24 Base.+(x, y)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op, itr)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op, Base.eltype(itr))\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op, :rf), _)\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _)\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_)\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\nChar\nWith type annotations:\njulia> @report_call annotate_types = true sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), a::String)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a::String)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), f::typeof(identity), a::String)\n│││┌ @ reduce.jl:503 Base.mapreduce(f::typeof(identity), Base.add_sum, a::String)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(mapreduce), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue()::Base._InitialValue, #self#::typeof(mapfoldl), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), init::Base._InitialValue, itr::String)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr′::String)\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String, Base.IteratorEltype(itr::String)::Base.HasEltype)\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op::Base.BottomRF{typeof(Base.add_sum)}, Base.eltype(itr::String)::Type{Char})\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum), _::Type{Char})\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _::Type{Char})\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_::Type{Char})\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String)\n││││││││││┌ @ reduce.jl:62 op::Base.BottomRF{typeof(Base.add_sum)}(v::Char, Base.getindex(y::Tuple{Char, Int64}, 1)::Char)\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum)(acc::Char, x::Char)\n││││││││││││┌ @ reduce.jl:24 Base.+(x::Char, y::Char)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\nChar\nnote: Note\nJET always annotates types when printing the error point, e.g. in the example above, the error points below are always type-annotated regardless of this configuration:no matching method found for call signature: Base.zero(_::Type{Char})\nno matching method found for call signature: Base.+(x::Char, y::Char)\n\n\n\nfullpath::Bool = false \nControls whether or not expand a file path to full path when printing analyzed call stack. Note that paths of Julia's Base files will also be expanded when set to true.\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.JETLogger","page":"JET Configurations","title":"JET.JETLogger","text":"Logging configurations for JET analysis:\n\n\n\ntoplevel_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's toplevel analysis. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> profile_file(filename; toplevel_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\nprofile_file(filename; toplevel_logger = IOContext(io, :JET_LOGGER_LEVEL => 1));\n\n\n\ninference_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's abstract interpretation routine. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level), 1 (\"debug\" level).\nExamples:\nlogs into stdout\nprofile_call(f, args...; inference_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\nprofile_call(f, args...; inference_logger = IOContext(io, :JET_LOGGER_LEVEL => 1))\n\n\n\ntip: Tip\nOf course you can specify both toplevel_logger and inference_logger at the same time like below:profile_and_watch_file(filename;\n                       toplevel_logger = IOContext(logger_io, :JET_LOGGER_LEVEL => 1),\n                       inference_logger = inference_io)\n\n\n\n\n\n","category":"type"}]
}
