var documenterSearchIndex = {"docs":
[{"location":"usages/#How-to-use-JET.jl","page":"Usages","title":"How to use JET.jl","text":"","category":"section"},{"location":"usages/","page":"Usages","title":"Usages","text":"WRITEME","category":"page"},{"location":"#JET.jl-–-experimental-type-checker-for-Julia,-no-need-for-additional-type-annotations","page":"README","title":"JET.jl – experimental type checker for Julia, no need for additional type annotations","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"JET","category":"page"},{"location":"#JET","page":"README","title":"JET","text":"(Image: CI) (Image: codecov)\n\nbehind the moar for performance ...\n\nJET.jl employs Julia's type inference for bug reports.\n\nnote: Note\nJET.jl needs Julia versions 1.6 and higher; as such I recommend you give a try on this package with using nightly version or building Julia from source. \nAlso note that JET deeply relies on the type inference routine implemented in Julia's compiler, and so JET analysis result can vary depending on your Julia version. In general, the newer your Julia version is, your can expect JET to analyze your code more accurately and quickly, because Julia's compiler is rapidly-advancing, literally day by day.\n\ndemo\n\nSay you have this strange and buggy file and want to know where to fix:\n\ndemo.jl\n\n# demo\n# ====\n\n# fibonacci\n# ---------\n\nfib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n\nfib(1000)   # never terminates in ordinal execution\nfib(m)      # undef var\nfib(\"1000\") # obvious type error\n\n\n# language features\n# -----------------\n\n# user-defined types\nstruct Ty{T}\n    fld::T\nend\n\nfunction foo(a)\n    v = Ty(a)\n    return bar(v)\nend\n\n# macros will be expanded\n@inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n@inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\nfoo(1.2)\nfoo(\"1\") # `String` can't be converted to `Number`\n\nYou can have JET.jl detect possible errors:\n\njulia> using JET\n\njulia> profile_and_watch_file(\"demo.jl\"; annotate_types = true)\n[toplevel-info] analysis entered into demo.jl\n[toplevel-info] analysis from demo.jl finished in 3.455 sec\n═════ 4 possible errors found ═════\n┌ @ demo.jl:10 fib(m)\n│ variable m is not defined: fib(m)\n└──────────────\n┌ @ demo.jl:11 fib(\"1000\")\n│┌ @ demo.jl:7 ≤(n::String, 2)\n││┌ @ operators.jl:385 Base.<(x::String, y::Int64)\n│││┌ @ operators.jl:336 Base.isless(x::String, y::Int64)\n││││ no matching method found for call signature: Base.isless(x::String, y::Int64)\n│││└────────────────────\n┌ @ demo.jl:32 foo(1.2)\n│┌ @ demo.jl:24 bar(v::Ty{Float64})\n││┌ @ demo.jl:29 Base.getproperty(v::Ty{Float64}, :fdl::Symbol)\n│││┌ @ Base.jl:33 Base.getfield(x::Ty{Float64}, f::Symbol)\n││││ type Ty{Float64} has no field fdl\n│││└──────────────\n┌ @ demo.jl:33 foo(\"1\")\n│┌ @ demo.jl:24 bar(v::Ty{String})\n││┌ @ demo.jl:30 convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n│││ no matching method found for call signature: convert(Number, Base.getproperty(v::Ty{String}, :fld::Symbol)::String)\n││└──────────────\n\nHooray ! JET.jl found possible error points (e.g. MethodError: no method matching isless(::String, ::Int64)) given toplevel call signatures of generic functions (e.g. fib(\"1000\")).\n\nNote that JET can find these errors while demo.jl is so inefficient (especially the fib implementation) that it would never terminate in actual execution. That is possible because JET analyzes code only on type level. This technique is often called \"abstract interpretation\" and JET internally uses Julia's native type inference implementation, so it can analyze code as fast/correctly as Julia's code generation.\n\nLastly let's apply the following diff to demo.jl so that it works nicely:\n\nfix-demo.jl.diff\n\ndiff --git a/demo.jl b/demo-fixed.jl\nindex d2b188a..1d1b3da 100644\n--- a/demo.jl\n+++ b/demo.jl\n@@ -5,11 +5,21 @@\n # fibonacci\n # ---------\n\n-fib(n) = n ≤ 2 ? n : fib(n-1) + fib(n-2)\n+# cache, cache, cache\n+function fib(n::T) where {T<:Number}\n+    cache = Dict(zero(T)=>zero(T), one(T)=>one(T))\n+    return _fib(n, cache)\n+end\n+_fib(n, cache) = if haskey(cache, n)\n+    cache[n]\n+else\n+    cache[n] = _fib(n-1, cache) + _fib(n-2, cache)\n+end\n\n-fib(1000)   # never terminates in ordinal execution\n-fib(m)      # undef var\n-fib(\"1000\") # obvious type error\n+fib(BigInt(1000)) # will terminate in ordinal execution as well\n+m = 1000          # define m\n+fib(m)\n+fib(parse(Int, \"1000\"))\n\n\n # language features\n@@ -27,8 +37,8 @@ end\n\n # macros will be expanded\n @inline bar(n::T)     where {T<:Number} = n < 0 ? zero(T) : one(T)\n-@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fdl) # typo \"fdl\"\n+@inline bar(v::Ty{T}) where {T<:Number} = bar(v.fld) # typo fixed\n @inline bar(v::Ty)                      = bar(convert(Number, v.fld))\n\n foo(1.2)\n-foo(\"1\") # `String` can't be converted to `Number`\n+foo('1') # `Char` will be converted to `UInt32`\n\nIf you apply the diff (i.e. update and save the demo.jl), JET will automatically re-trigger profiling, and this time, won't complain anything:\n\ngit apply fix-demo.jl.diff\n\n[toplevel-info] analysis entered into demo.jl\n[toplevel-info] analysis from demo.jl finished in 3.423 sec\nNo errors !\n\nTODOs\n\ndocumentation: WIP at https://github.com/aviatesk/JET.jl/pull/127\nrelease: see https://github.com/aviatesk/JET.jl/issues/121\nremove Core.eval(CC, ...) monkey patches (https://github.com/JuliaLang/julia/pull/39439, https://github.com/JuliaLang/julia/pull/39305, see also \"developer note\" section)\nmore accurate error reports in general\nenable constant propagation on union-split signatures (https://github.com/JuliaLang/julia/pull/39305)\nprovide editor/IDE integrations for \"watch\" mode (https://github.com/aviatesk/JET.jl/pull/85 will be a starting point)\nsupport package profiling (issue https://github.com/aviatesk/JET.jl/issues/76, something like PR https://github.com/aviatesk/JET.jl/pull/101 can be a starting point)\nimplement a \"global\" version of type inference algorithm (see this comment)\nperformance linting (report performance pitfalls, i.e. report an error when there're too many methods matched)\nideally, I want to extend JET.jl to provide some of LSPs other than diagnostics, e.g. providers of completions, rename refactor, etc.\n\nacknowledgement\n\nThis project started as my grad thesis project at Kyoto University, supervised by Prof. Takashi Sakuragawa. We were heavily inspired by ruby/typeprof, an experimental type understanding/checking tool for Ruby. The grad thesis about this project is published at https://github.com/aviatesk/grad-thesis, but currently it's only available in Japanese.\n\n\n\n\n\n","category":"module"},{"location":"internals/#JET-Internals","page":"Internals","title":"JET Internals","text":"","category":"section"},{"location":"internals/#Toplevel-Analysis","page":"Internals","title":"Toplevel Analysis","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.virtual_process!\nJET.partially_interpret!\nJET.ConcreteInterpreter\nJET.AbstractGlobal","category":"page"},{"location":"internals/#JET.virtual_process!","page":"Internals","title":"JET.virtual_process!","text":"virtual_process!(s::AbstractString,\n                 filename::AbstractString,\n                 virtualmod::Module,\n                 actualmodsym::Symbol,\n                 interp::JETInterpreter,\n                 )::Tuple{VirtualProcessResult,JETInterpreter}\nvirtual_process!(toplevelex::Expr,\n                 filename::AbstractString,\n                 virtualmod::Module,\n                 actualmodsym::Symbol,\n                 interp::JETInterpreter,\n                 )::Tuple{VirtualProcessResult,JETInterpreter}\n\nsimulates Julia's toplevel execution and profiles error reports, and returns res::VirtualProcessResult, which keeps the following information:\n\nres.included_files::Set{String}: files that have been profiled\nres.toplevel_error_reports::Vector{ToplevelErrorReport}: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are \"critical\" and should   have precedence over inference_error_reports\nres.inference_error_reports::Vector{InferenceErrorReport}: possible error reports found   by JETInterpreter\n\nthis function first parses s::AbstractString into toplevelex::Expr and then iterate the   following steps on each code block (blk) of toplevelex:\n\nif blk is a :module expression, recusively call virtual_process! with an newly defined   virtual module\nlowers blk into :thunk expression lwr (macros are also expanded in this step)\nreplaces self-references of the original root module (that is represented as actualmodsym)   with that of virtualmod: see fix_self_references\nConcreteInterpreter partially interprets some statements in lwr that should not be   abstracted away (e.g. a :method definition); see also partially_interpret!\nfinally, JETInterpreter profiles the remaining statements by abstract interpretation\n\nwarning: Warning\nthe current approach splits entire code into code blocks and we're not tracking   inter-code-block level dependencies, and so a partial interpretation of toplevle   definitions will fail if it needs an access to global variables that are defined   in the other code block\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.partially_interpret!","page":"Internals","title":"JET.partially_interpret!","text":"partially_interpret!(interp, mod, src)\n\npartially interprets statements in src using JuliaInterpreter.jl:\n\nconcretize \"toplevel definitions\", i.e. :method, :struct_type, :abstract_type and   :primitive_type expressions and their dependencies\ndirectly evaluates module usage expressions and report error of invalid module usages;   or profile the package loading\nspecial case include calls so that virtual_process! recursively runs on the   included file\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.ConcreteInterpreter","page":"Internals","title":"JET.ConcreteInterpreter","text":"ConcreteInterpreter\n\ntrait to inject code into JuliaInterpreter's interpretation process; JET.jl overloads:\n\nJuliaInterpreter.step_expr! to add error report pass for module usage expressions and   support package profiling\nJuliaInterpreter.evaluate_call_recurse! to special case include calls\nJuliaInterpreter.handle_err to wrap an error happened during interpretation into   ActualErrorWrapped\n\n\n\n\n\n","category":"type"},{"location":"internals/#JET.AbstractGlobal","page":"Internals","title":"JET.AbstractGlobal","text":"mutable struct AbstractGlobal\n    # analyzed type\n    t::Any\n    # `id` of `JETInterpreter` that defined this\n    id::Symbol\n    # `Symbol` of a dummy generic function that generates dummy backedge (i.e. `li`)\n    edge_sym::Symbol\n    # dummy backedge, which will be invalidated on update of `t`\n    li::MethodInstance\n    # whether this abstract global variable is declarared as constant or not\n    iscd::Bool\nend\n\nWraps a global variable whose type is analyzed by abtract interpretation. AbstractGlobal object will be actually evaluated into the context module, and a later   analysis may refer to its type or alter it on another assignment. On the refinement of the abstract global variable, the dummy backedge associated with it   will be invalidated, and inference depending on that will be re-run on the next analysis.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Abstract-Interpretation","page":"Internals","title":"Abstract Interpretation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.jl overloads functions from Juila's Core.Compiler module, which are intended for its native JIT type inference.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"They're overloaded on JETInterpreter so that typeinf(::JETInterpreter, ::InferenceState) will do abstract interpretation tuned for JET.jl's type error analysis. Most overloads are done by using invoke, which allows us to call down to and reuse the original NativeInterpreter's abstract interpretation methods while passing JETInterpreter for subsequent (maybe overloaded) callees (see JET.@invoke macro).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"But sometimes we can't just use @invoke and have to change/discard some logics that are hard-coded within original native function. In such cases, currently JET.jl copy-and-pasted the original body of the overloaded function and applies monkey patches. I'm planning to remove those monkey patches by adding some tweaks to Julia's compiler code itself, but for now, in order to keep the least maintainability, we do:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"use syntactic hacks (#=== ... ===#) to indicate the locations and purposes of each patch\neach overload is directly evaluated in the Core.Compiler module so that we don't need to maintain miscellaneous imports\nas such, the overloads are done within __init__ hook; there are wrapper functions whose name starts with overload_  for each overloading and the wrappers are registered to push_inithook!\nthe docstrings of the wrappers tell the purposes of each overload","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.overload_abstract_call_gf_by_type!\nJET.overload_abstract_call_method_with_const_args!\nJET.is_from_same_frame","category":"page"},{"location":"internals/#JET.overload_abstract_call_gf_by_type!","page":"Internals","title":"JET.overload_abstract_call_gf_by_type!","text":"function overload_abstract_call_gf_by_type!()\n    ...\nend\npush_inithook!(overload_abstract_call_gf_by_type!)\n\nthe aims of this overload are:\n\nreport NoMethodErrorReport on empty method signature matching\nkeep inference on non-concrete call sites in toplevel frame created by virtual_process!\ndon't bail out even after the current return type grows up to Any and collect as much error points as possible; of course it slows down inference performance, but hopefully it stays to be \"practical\" speed (because the number of matching methods is limited beforehand)\nforce constant prop' even if the inference result can't be improved anymore when rettype is already Const; this is because constant prop' can still produce more \"correct\" analysis by throwing away the error reports in the callee frames\nalways add backedges (even if a new method can't refine the return type grew up toAny), because a new method always may change the JET analysis result\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.overload_abstract_call_method_with_const_args!","page":"Internals","title":"JET.overload_abstract_call_method_with_const_args!","text":"function overload_abstract_call_method_with_const_args!()\n    ...\nend\npush_inithook!(overload_abstract_call_method_with_const_args!)\n\nthe aim of this overloads is:\n\nforce constant prop' even if the inference result can't be improved anymore when rettype is already Const; this is because constant prop' can still produce more \"correct\" analysis by throwing away the error reports in the callee frames\n\n\n\n\n\n","category":"function"},{"location":"internals/#JET.is_from_same_frame","page":"Internals","title":"JET.is_from_same_frame","text":"is_from_same_frame(parent_linfo::MethodInstance, current_linfo::MethodInstance) ->\n    (report::InferenceErrorReport) -> Bool\n\nReturns a function that checks if a given InferenceErrorReport is generated from current_linfo. It also checks current_linfo is a \"lineage\" of parent_linfo (i.e. entered from it).\n\nThis function is supposed to be used to filter out reports from analysis on current_linfo   without using constants when entering into the constant analysis. As such, this function   assumes that when a report should be filtered out, the first elment of its virtual stack   frame st is for parent_linfo and the second element of that is for current_linfo.\n\nExample: Assume linfo2 will produce a report for some reason. In the example analysis below, report2 will be filtered out on re-entering into linfo3   with constants (i.e. linfo3′). Note that report1 is still kept there because of the   lineage check.\n\nentry\n└─ linfo1\n   ├─ linfo2 (report1: linfo2)\n   ├─ linfo3 (report1: linfo1->linfo2, report2: linfo3->linfo2)\n   │  └─ linfo2 (report1: linfo2, report2: linfo2)\n   └─ linfo3′ (report1: linfo1->linfo2, ~~report2: linfo1->linfo3->linfo2~~)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Utilities","page":"Internals","title":"Utilities","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"JET.@invoke\nJET.@invokelatest\nJET.@withmixedhash\nJET.@jetconfigurable","category":"page"},{"location":"internals/#JET.@invoke","page":"Internals","title":"JET.@invoke","text":"@invoke f(arg::T, ...; kwargs...)\n\nProvides a convenient way to call invoke; @invoke f(arg1::T1, arg2::T2; kwargs...) will be expanded into invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...). When an argument's type annotation is omitted, it's specified as Any argument, e.g. @invoke f(arg1::T, arg2) will be expanded into invoke(f, Tuple{T,Any}, arg1, arg2).\n\nThis could be used to call down to NativeInterpreter's abstract interpretation method of   f while passing JETInterpreter so that subsequent calls of abstract interpretation   functions overloaded against JETInterpreter can be called from the native method of f; e.g. calls down to NativeInterpreter's abstract_call_gf_by_type method:\n\n@invoke abstract_call_gf_by_type(interp::AbstractInterpreter, f, argtypes::Vector{Any}, atype, sv::InferenceState,\n                                 max_methods::Int)\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@invokelatest","page":"Internals","title":"JET.@invokelatest","text":"@invokelatest f(args...; kwargs...)\n\nProvides a convenient way to call Base.invokelatest. @invokelatest f(args...; kwargs...) will simply be expanded into Base.invokelatest(f, args...; kwargs...).\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@withmixedhash","page":"Internals","title":"JET.@withmixedhash","text":"@withmixedhash (mutable) struct T\n    fields ...\nend\n\nDefines struct T while automatically defining its Base.hash(::T, ::UInt) method which   mixes hashes of all of T's fields (and also corresponding Base.:(==)(::T, ::T) method).\n\nThis macro is supposed to abstract the following kind of pattern:\n\nhttps://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25\n\nstruct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\n==(a::PkgId, b::PkgId) = a.uuid == b.uuid && a.name == b.name\n\nfunction hash(pkg::PkgId, h::UInt)\n    h += 0xc9f248583a0ca36c % UInt\n    h = hash(pkg.uuid, h)\n    h = hash(pkg.name, h)\n    return h\nend\n\nwith @withmixedhash\n\n@withmixedhash struct PkgId\n    uuid::Union{UUID,Nothing}\n    name::String\nend\n\nSee also: EGAL_TYPES\n\n\n\n\n\n","category":"macro"},{"location":"internals/#JET.@jetconfigurable","page":"Internals","title":"JET.@jetconfigurable","text":"@jetconfigurable function config_func(args...; configurations...)\n    ...\nend\n\nThis macro asserts that there's no configuration naming conflict across the @jetconfigurable   functions so that a configuration for a @jetconfigurable function  doesn't affect the other   @jetconfigurable functions. This macro also adds a dummy splat keyword arguments (jetconfigs...) to the function definition   so that any configuration of other @jetconfigurable functions can be passed on to it.\n\n\n\n\n\n","category":"macro"},{"location":"config/#JET-Configurations","page":"Configurations","title":"JET Configurations","text":"","category":"section"},{"location":"config/","page":"Configurations","title":"Configurations","text":"JET.JETAnalysisParams\nJET.JETInferenceParams\nJET.PrintConfig\nJET.WatchConfig\nJET.JETLogger","category":"page"},{"location":"config/#JET.JETAnalysisParams","page":"Configurations","title":"JET.JETAnalysisParams","text":"Configurations for JET analysis\n\n\n\nstrict_condition_check::Bool = false \nEnables strict condition check. JET reports an error if a condition expression type is \"non-boolean\". In a case when   the condition type is Union, JET will report if either of union split case is   non-boolean type, but this can lead to lots of false positive error reports when the   code is not well-typed, because Julia Base defines generic functions that are commonly   used at a conditional context but also may return \"non-boolean\" values, e.g.:\n!(::Function) -> Function\n!(::Missing) -> Missing\n==(::Missing, ::Any) -> Missing\n==(::Any, ::Missing) -> Missing\nand thus loosely-typed conditional expression often becomes e.g. Union{Bool, Missing},   and consequently JET will report it as \"non-boolean\" type   (NOTE: in Julia Missing is certainly not valid conditional type). If this configuration is set to false, JET enables an heuristic to avoid those false   positive error reports and won't report an error if a condition expression type is   Union and either of its union split case is Function or Missing.\nThe effect of this configuration can be described with the following examples:\nwith strict_condition_check::Bool = false (default)\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call test_f()\nNo errors !\nDict{Any, Int64}\nwith strict_condition_check::Bool = true\njulia> test_f() = Dict('a' => 1, :b => 2) # ::Dict{Any,Int}\ntest_f (generic function with 1 method)\n\njulia> @report_call strict_condition_check = true test_f()\n═════ 1 possible error found ═════\n┌ @ REPL[2]:1 Main.Dict(Main.=>('a', 1), Main.=>(:b, 2))\n│┌ @ dict.jl:125 Base.Dict(ps)\n││┌ @ dict.jl:129 Base.dict_with_eltype(#308, kv, Base.eltype(kv))\n│││┌ @ abstractdict.jl:539 Base.grow_to!(Base.dict_with_eltype(DT_apply, _5), kv)\n││││┌ @ dict.jl:145 Base.grow_to!(dest2, itr, st)\n│││││┌ @ dict.jl:159 Base.setindex!(new, v, k)\n││││││┌ @ dict.jl:383 Base.ht_keyindex2!(h, key)\n│││││││┌ @ dict.jl:328 goto %35 if not Base.isequal(key, Base.getindex(keys, index))\n││││││││ for 1 of union split cases, non-boolean (Missing) used in boolean context: goto %35 if not Base.isequal(key::Symbol, Base.getindex(keys::Vector{Any}, index::Int64)::Any)::Union{Missing, Bool}\n│││││││└───────────────\nDict{Any, Int64}\n\n\n\nignore_native_remarks::Bool = true \nIf true, JET won't construct nor cache reports of \"native remarks\", which may speed up analysis time. \"Native remarks\" are information that Julia's native compiler emits about how type inference routine goes, and those remarks are less interesting in term of \"error checking\", so JET ignores them by default.\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.JETInferenceParams","page":"Configurations","title":"JET.JETInferenceParams","text":"Configurations for Julia's native type inference routine\n\n\n\nipo_constant_propagation::Bool = true \nEnables constant propagation in abstract interpretation. It is highly recommended that you keep this configuration true to get reasonable analysis, because constant propagation can cut off lots of false positive errorenous code paths and thus lead to more accurate and useful analysis results.\n\n\n\naggressive_constant_propagation::Bool = true \nIf true, JET will try to do constant propagation more \"aggressively\". As explained above, it can lead to more accurate analysis, but also lead to worse analysis performance at the cost of that.\n\n\n\nunoptimize_throw_blocks::Bool = false \nTurn this on to skip analysis on code blocks that will eventually lead to a throw call. This configuration may improve the analysis performance, but it's better to be turned off   for JET analysis, because there may be other errors even in those code blocks.\n\n\n\nnote: Note\nYou can also specify all the other parameters that Core.Compiler.InferenceParams can accept, e.g. max_methods::Int = 3, union_splitting::Int = 4, etc.\n\n\n\n\n\n","category":"function"},{"location":"config/#JET.PrintConfig","page":"Configurations","title":"JET.PrintConfig","text":"JET configurations for error printing\n\n\n\nprint_toplevel_success::Bool = false \nIf true, prints a message when there is no toplevel errors found.\n\n\n\nprint_inference_sucess::Bool = true \nIf true, print a message when there is no errors found in abstract interpretation based analysis pass.\n\n\n\nannotate_types::Bool = false \nWhen set to true, annotates types when printing analyzed call stack. Here are examples:\nwith annotate_types = false (default):\njulia> @report_call sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()), #self#, a)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()), #self#, f, a)\n│││┌ @ reduce.jl:503 Base.mapreduce(f, Base.add_sum, a)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()), #self#, f, op, itr)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f, op, itr)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue(), #self#, f, op, itr)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f, op, init, itr)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′, nt, itr′)\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op, nt, itr)\n││││││││││┌ @ reduce.jl:62 op(v, Base.getindex(y, 1))\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op, :rf)(acc, x)\n││││││││││││┌ @ reduce.jl:24 Base.+(x, y)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op, itr)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op, itr, Base.IteratorEltype(itr))\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op, Base.eltype(itr))\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op, :rf), _)\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _)\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_)\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\nChar\nwith annotate_types = true\njulia> @report_call annotate_types = true sum(\"julia\")\n═════ 2 possible errors found ═════\n┌ @ reduce.jl:530 Base.#sum#241(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), a::String)\n│┌ @ reduce.jl:530 Base.sum(Base.identity, a::String)\n││┌ @ reduce.jl:503 Base.#sum#240(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(sum), f::typeof(identity), a::String)\n│││┌ @ reduce.jl:503 Base.mapreduce(f::typeof(identity), Base.add_sum, a::String)\n││││┌ @ reduce.jl:289 Base.#mapreduce#237(Base.pairs(Core.NamedTuple()::NamedTuple{(), Tuple{}})::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, #self#::typeof(mapreduce), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││┌ @ reduce.jl:289 Base.mapfoldl(f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n││││││┌ @ reduce.jl:162 Base.#mapfoldl#233(Base._InitialValue()::Base._InitialValue, #self#::typeof(mapfoldl), f::typeof(identity), op::typeof(Base.add_sum), itr::String)\n│││││││┌ @ reduce.jl:162 Base.mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), init::Base._InitialValue, itr::String)\n││││││││┌ @ reduce.jl:44 Base.foldl_impl(op′::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr′::String)\n│││││││││┌ @ reduce.jl:49 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String)\n││││││││││┌ @ reduce.jl:356 Base.reduce_empty_iter(op::Base.BottomRF{typeof(Base.add_sum)}, itr::String, Base.IteratorEltype(itr::String)::Base.HasEltype)\n│││││││││││┌ @ reduce.jl:357 Base.reduce_empty(op::Base.BottomRF{typeof(Base.add_sum)}, Base.eltype(itr::String)::Type{Char})\n││││││││││││┌ @ reduce.jl:330 Base.reduce_empty(Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum), _::Type{Char})\n│││││││││││││┌ @ reduce.jl:322 Base.reduce_empty(Base.+, _::Type{Char})\n││││││││││││││┌ @ reduce.jl:313 Base.zero(_::Type{Char})\n│││││││││││││││ no matching method found for call signature: Base.zero(_::Type{Char})\n││││││││││││││└─────────────────\n│││││││││┌ @ reduce.jl:48 Base._foldl_impl(op::Base.BottomRF{typeof(Base.add_sum)}, nt::Base._InitialValue, itr::String)\n││││││││││┌ @ reduce.jl:62 op::Base.BottomRF{typeof(Base.add_sum)}(v::Char, Base.getindex(y::Tuple{Char, Int64}, 1)::Char)\n│││││││││││┌ @ reduce.jl:81 Base.getproperty(op::Base.BottomRF{typeof(Base.add_sum)}, :rf::Symbol)::typeof(Base.add_sum)(acc::Char, x::Char)\n││││││││││││┌ @ reduce.jl:24 Base.+(x::Char, y::Char)\n│││││││││││││ no matching method found for call signature: Base.+(x::Char, y::Char)\n││││││││││││└────────────────\nChar\nnote: Note\nJET always annotates types when printing the error point, e.g. in the example above, the error points below are always type-annotated regardless of this configuration:no matching method found for call signature: Base.zero(_::Type{Char})\nno matching method found for call signature: Base.+(x::Char, y::Char)\n\n\n\nfullpath::Bool = false \nControls whether or not expand a file path to full path when printing analyzed call stack. Note that paths of Julia's Base files will also be expanded when set to true.\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.WatchConfig","page":"Configurations","title":"JET.WatchConfig","text":"Configurations for \"watch\" mode\n\n\n\nrevise_all::Bool = true \nRedirected to Revise.entr's all keyword argument. When set to true, JET will retrigger analysis as soon as code updates are detected in   any module tracked by Revise. Currently when encountering import/using statements, JET won't perform analysis, but   rather will just load the modules as usual execution (this also means Revise will track   those modules). So if you're editing both files analyzed by JET and modules that are used within the files,   this configuration should be enabled.\n\n\n\nrevise_modules = nothing \nRedirected to Revise.entr's modules positional argument. If a iterator of Module is given, JET will retrigger analysis whenever code in modules updates.\ntip: Tip\nThis configuration is useful when your're also editing files that are not tracked by Revise, e.g. editing functions defined in Base:# re-performe analysis when you make a change to `Base`\nprofile_and_watch_file(yourfile; revise_modules = [Base])\n\n\n\n\n\n","category":"type"},{"location":"config/#JET.JETLogger","page":"Configurations","title":"JET.JETLogger","text":"Logging configurations for JET analysis\n\n\n\ntoplevel_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's toplevel analysis. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level), 1 (\"debug\" level).\nExamples:\nlogs into stdout\njulia> profile_file(filename; toplevel_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\nprofile_file(filename; toplevel_logger = IOContext(io, :JET_LOGGER_LEVEL => 1));\n\n\n\ninference_logger::Union{Nothing,IO} = nothing \nIf IO object is given, it will track JET's abstract interpretation routine. Logging level can be specified with :JET_LOGGER_LEVEL IO property. Currently supported logging levels are either of 0 (\"info\" level), 1 (\"debug\" level).\nExamples:\nlogs into stdout\nprofile_call(f, args...; inference_logger = stdout)\nlogs into io::IOBuffer with \"debug\" logger level\nprofile_call(f, args...; inference_logger = IOContext(io, :JET_LOGGER_LEVEL => 1))\n\n\n\ntip: Tip\nOf course you can specify both toplevel_logger and inference_logger at the same time like below:profile_and_watch_file(filename;\n                       toplevel_logger = IOContext(logger_io, :JET_LOGGER_LEVEL => 1),\n                       inference_logger = inference_io)\n\n\n\n\n\n","category":"type"}]
}
