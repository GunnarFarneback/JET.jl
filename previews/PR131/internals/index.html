<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · JET.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JET.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">README</a></li><li><a class="tocitem" href="../usages/">Usages</a></li><li><a class="tocitem" href="../config/">Configurations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Interpretation"><span>Abstract Interpretation</span></a></li><li><a class="tocitem" href="#Toplevel-Analysis"><span>Toplevel Analysis</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JET.jl/blob/master/docs/src/internals.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JET&#39;s-Internals"><a class="docs-heading-anchor" href="#JET&#39;s-Internals">JET&#39;s Internals</a><a id="JET&#39;s-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#JET&#39;s-Internals" title="Permalink"></a></h1><h2 id="Abstract-Interpretation"><a class="docs-heading-anchor" href="#Abstract-Interpretation">Abstract Interpretation</a><a id="Abstract-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Interpretation" title="Permalink"></a></h2><p>JET.jl overloads functions from Juila&#39;s <a href="https://github.com/JuliaLang/julia/tree/master/base/compiler"><code>Core.Compiler</code></a> module, which are intended for its native JIT type inference.</p><p>They&#39;re overloaded on <code>JETInterpreter</code> so that <code>typeinf(::JETInterpreter, ::InferenceState)</code> will do abstract interpretation tuned for JET.jl&#39;s type error analysis. Most overloads are done by using <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a>, which allows us to call down to and reuse the original <code>NativeInterpreter</code>&#39;s abstract interpretation methods while passing <code>JETInterpreter</code> for subsequent (maybe overloaded) callees (see <a href="#JET.@invoke"><code>JET.@invoke</code></a> macro).</p><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_toplevel_call" href="#Core.Compiler.bail_out_toplevel_call"><code>Core.Compiler.bail_out_toplevel_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_toplevel_call(interp::JETInterpreter, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code>, which keeps   inference on non-concrete call sites in a toplevel frame created by   <a href="#JET.virtual_process!"><code>virtual_process!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.bail_out_call" href="#Core.Compiler.bail_out_call"><code>Core.Compiler.bail_out_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bail_out_call(interp::JETInterpreter, ...)</code></pre><p>With this overload, <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code> doesn&#39;t bail out   inference even after the current return type grows up to <code>Any</code> and collects as much error   points as possible. Of course this slows down inference performance, but hoopefully it stays to be &quot;practical&quot;   speed since the number of matching methods are limited beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.add_call_backedges!" href="#Core.Compiler.add_call_backedges!"><code>Core.Compiler.add_call_backedges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_call_backedges!(interp::JETInterpreter, ...)</code></pre><p>An overload for <code>abstract_call_gf_by_type(interp::JETInterpreter, ...)</code>, which always add   backedges (even if a new method can&#39;t refine the return type grew up to <code>Any</code>). This is because a new method definition always has a potential to change the JET analysis result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Compiler.const_prop_entry_heuristic" href="#Core.Compiler.const_prop_entry_heuristic"><code>Core.Compiler.const_prop_entry_heuristic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">const_prop_entry_heuristic(interp::JETInterpreter, @nospecialize(rettype), sv::InferenceState, edgecycle::Bool)</code></pre><p>An overload for <code>abstract_call_method_with_const_args(interp::JETInterpreter, ...)</code>, which   forces constant prop&#39; even if the inference result can&#39;t be improved anymore, e.g. when   <code>rettype</code> is already <code>Const</code>; this is because constant prop&#39; can still produce more accurate   analysis by throwing away false positive error reports by cutting off the unreachable   control flow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L157-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.analyze_task_parallel_code!" href="#JET.analyze_task_parallel_code!"><code>JET.analyze_task_parallel_code!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_task_parallel_code!(interp::JETInterpreter, @nospecialize(f), argtypes::Vector{Any}, sv::InferenceState)</code></pre><p>Adds special cased analysis pass for task parallelism (xref: https://github.com/aviatesk/JET.jl/issues/114). In Julia&#39;s task parallelism implementation, parallel code is represented as closure and it&#39;s   wrapped in a <code>Task</code> object. <code>NativeInterpreter</code> doesn&#39;t run type inference nor optimization   on the body of those closures when compiling code that creates parallel tasks, but JET will   try to run additional analysis pass by recurring into the closures.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>JET won&#39;t do anything other than doing JET analysis, e.g. won&#39;t annotate return type of wrapped code block in order to not confuse the original <code>AbstractInterpreter</code> routine track <a href="https://github.com/JuliaLang/julia/pull/39773">https://github.com/JuliaLang/julia/pull/39773</a> for the changes in native abstract interpretation routine.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L185-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.is_from_same_frame" href="#JET.is_from_same_frame"><code>JET.is_from_same_frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_from_same_frame(parent_linfo::MethodInstance, current_linfo::MethodInstance) -&gt;
    (report::InferenceErrorReport) -&gt; Bool</code></pre><p>Returns a function that checks if a given <code>InferenceErrorReport</code> is generated from <code>current_linfo</code>. It also checks <code>current_linfo</code> is a &quot;lineage&quot; of <code>parent_linfo</code> (i.e. entered from it).</p><p>This function is supposed to be used to filter out reports from analysis on <code>current_linfo</code>   without using constants when entering into the constant analysis. As such, this function   assumes that when a report should be filtered out, the first elment of its virtual stack   frame <code>st</code> is for <code>parent_linfo</code> and the second element of that is for <code>current_linfo</code>.</p><p>Example: Assume <code>linfo2</code> will produce a report for some reason. In the example analysis below, <code>report2</code> will be filtered out on re-entering into <code>linfo3</code>   with constants (i.e. <code>linfo3′</code>). Note that <code>report1</code> is still kept there because of the   lineage check.</p><pre><code class="language-none">entry
└─ linfo1
   ├─ linfo2 (report1: linfo2)
   ├─ linfo3 (report1: linfo1-&gt;linfo2, report2: linfo3-&gt;linfo2)
   │  └─ linfo2 (report1: linfo2, report2: linfo2)
   └─ linfo3′ (report1: linfo1-&gt;linfo2, ~~report2: linfo1-&gt;linfo3-&gt;linfo2~~)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/typeinfer.jl#L214-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.AbstractGlobal" href="#JET.AbstractGlobal"><code>JET.AbstractGlobal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AbstractGlobal
    # analyzed type
    t::Any
    # `id` of `JETInterpreter` that defined this
    id::Symbol
    # `Symbol` of a dummy generic function that generates dummy backedge (i.e. `li`)
    edge_sym::Symbol
    # dummy backedge, which will be invalidated on update of `t`
    li::MethodInstance
    # whether this abstract global variable is declarared as constant or not
    iscd::Bool
end</code></pre><p>Wraps a global variable whose type is analyzed by abtract interpretation. <code>AbstractGlobal</code> object will be actually evaluated into the context module, and a later   analysis may refer to its type or alter it on another assignment. On the refinement of the abstract global variable, the dummy backedge associated with it   will be invalidated, and inference depending on that will be re-run on the next analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/abstractinterpretation.jl#L1-L20">source</a></section></article><h2 id="Toplevel-Analysis"><a class="docs-heading-anchor" href="#Toplevel-Analysis">Toplevel Analysis</a><a id="Toplevel-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Toplevel-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.virtual_process!" href="#JET.virtual_process!"><code>JET.virtual_process!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">virtual_process!(s::AbstractString,
                 filename::AbstractString,
                 virtualmod::Module,
                 actualmodsym::Symbol,
                 interp::JETInterpreter,
                 ) -&gt; Tuple{VirtualProcessResult,JETInterpreter}
virtual_process!(toplevelex::Expr,
                 filename::AbstractString,
                 virtualmod::Module,
                 actualmodsym::Symbol,
                 interp::JETInterpreter,
                 ) -&gt; Tuple{VirtualProcessResult,JETInterpreter}</code></pre><p>simulates Julia&#39;s toplevel execution and analyzes error points, and returns <code>res::VirtualProcessResult</code>, which keeps the following information:</p><ul><li><code>res.included_files::Set{String}</code>: files that have been analyzed</li><li><code>res.toplevel_error_reports::Vector{ToplevelErrorReport}</code>: toplevel errors found during the   text parsing or partial (actual) interpretation; these reports are &quot;critical&quot; and should   have precedence over <code>inference_error_reports</code></li><li><code>res.inference_error_reports::Vector{InferenceErrorReport}</code>: possible error reports found   by <code>JETInterpreter</code></li></ul><p>this function first parses <code>s::AbstractString</code> into <code>toplevelex::Expr</code> and then iterate the   following steps on each code block (<code>blk</code>) of <code>toplevelex</code>:</p><ol><li>if <code>blk</code> is a <code>:module</code> expression, recusively call <code>virtual_process!</code> with an newly defined   virtual module</li><li><code>lower</code>s <code>blk</code> into <code>:thunk</code> expression <code>lwr</code> (macros are also expanded in this step)</li><li>replaces self-references of the original root module (that is represented as <code>actualmodsym</code>)   with that of <code>virtualmod</code>: see <code>fix_self_references</code></li><li><code>ConcreteInterpreter</code> partially interprets some statements in <code>lwr</code> that should not be   abstracted away (e.g. a <code>:method</code> definition); see also <a href="#JET.partially_interpret!"><code>partially_interpret!</code></a></li><li>finally, <code>JETInterpreter</code> analyzes the remaining statements by abstract interpretation</li></ol><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>the current approach splits entire code into code blocks and we&#39;re not tracking   inter-code-block level dependencies, and so a partial interpretation of toplevle   definitions will fail if it needs an access to global variables that are defined   in the other code block</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/virtualprocess.jl#L12-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.partially_interpret!" href="#JET.partially_interpret!"><code>JET.partially_interpret!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partially_interpret!(interp, mod, src)</code></pre><p>partially interprets statements in <code>src</code> using JuliaInterpreter.jl:</p><ul><li>concretize &quot;toplevel definitions&quot;, i.e. <code>:method</code>, <code>:struct_type</code>, <code>:abstract_type</code> and   <code>:primitive_type</code> expressions and their dependencies</li><li>directly evaluates module usage expressions and report error of invalid module usages (TODO: enter into the loaded module and keep JET analysis)</li><li>special case <code>include</code> calls so that <a href="#JET.virtual_process!"><code>virtual_process!</code></a> recursively runs on the   included file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/virtualprocess.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.ConcreteInterpreter" href="#JET.ConcreteInterpreter"><code>JET.ConcreteInterpreter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConcreteInterpreter</code></pre><p>trait to inject code into JuliaInterpreter&#39;s interpretation process; JET.jl overloads:</p><ul><li><code>JuliaInterpreter.step_expr!</code> to add error report pass for module usage expressions and   support package profiling</li><li><code>JuliaInterpreter.evaluate_call_recurse!</code> to special case <code>include</code> calls</li><li><code>JuliaInterpreter.handle_err</code> to wrap an error happened during interpretation into   <code>ActualErrorWrapped</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/virtualprocess.jl#L339-L348">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JET.@invoke" href="#JET.@invoke"><code>JET.@invoke</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invoke f(arg::T, ...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Core.invoke"><code>invoke</code></a>; <code>@invoke f(arg1::T1, arg2::T2; kwargs...)</code> will be expanded into <code>invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...)</code>. When an argument&#39;s type annotation is omitted, it&#39;s specified as <code>Any</code> argument, e.g. <code>@invoke f(arg1::T, arg2)</code> will be expanded into <code>invoke(f, Tuple{T,Any}, arg1, arg2)</code>.</p><p>This could be used to call down to <code>NativeInterpreter</code>&#39;s abstract interpretation method of   <code>f</code> while passing <code>JETInterpreter</code> so that subsequent calls of abstract interpretation   functions overloaded against <code>JETInterpreter</code> can be called from the native method of <code>f</code>; e.g. calls down to <code>NativeInterpreter</code>&#39;s <code>abstract_call_gf_by_type</code> method:</p><pre><code class="language-julia">@invoke abstract_call_gf_by_type(interp::AbstractInterpreter, f, argtypes::Vector{Any}, atype, sv::InferenceState,
                                 max_methods::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/JET.jl#L184-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@invokelatest" href="#JET.@invokelatest"><code>JET.@invokelatest</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@invokelatest f(args...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="https://docs.julialang.org/en/v1/base/base/#Base.invokelatest"><code>Base.invokelatest</code></a>. <code>@invokelatest f(args...; kwargs...)</code> will simply be expanded into <code>Base.invokelatest(f, args...; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/JET.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@withmixedhash" href="#JET.@withmixedhash"><code>JET.@withmixedhash</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@withmixedhash (mutable) struct T
    fields ...
end</code></pre><p>Defines struct <code>T</code> while automatically defining its <code>Base.hash(::T, ::UInt)</code> method which   mixes hashes of all of <code>T</code>&#39;s fields (and also corresponding <code>Base.:(==)(::T, ::T)</code> method).</p><p>This macro is supposed to abstract the following kind of pattern:</p><blockquote><p>https://github.com/aviatesk/julia/blob/999973df2850d6b2e0bd4bcf03ef90a14217b63c/base/pkgid.jl#L3-L25</p></blockquote><pre><code class="language-julia">struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end

==(a::PkgId, b::PkgId) = a.uuid == b.uuid &amp;&amp; a.name == b.name

function hash(pkg::PkgId, h::UInt)
    h += 0xc9f248583a0ca36c % UInt
    h = hash(pkg.uuid, h)
    h = hash(pkg.name, h)
    return h
end</code></pre><blockquote><p>with <code>@withmixedhash</code></p></blockquote><pre><code class="language-julia">@withmixedhash struct PkgId
    uuid::Union{UUID,Nothing}
    name::String
end</code></pre><p>See also: <a href="@ref"><code>EGAL_TYPES</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/JET.jl#L244-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JET.@jetconfigurable" href="#JET.@jetconfigurable"><code>JET.@jetconfigurable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@jetconfigurable function config_func(args...; configurations...)
    ...
end</code></pre><p>This macro asserts that there&#39;s no configuration naming conflict across the <code>@jetconfigurable</code>   functions so that a configuration for a <code>@jetconfigurable</code> function  doesn&#39;t affect the other   <code>@jetconfigurable</code> functions. This macro also adds a dummy splat keyword arguments (<code>jetconfigs...</code>) to the function definition   so that any configuration of other <code>@jetconfigurable</code> functions can be passed on to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JET.jl/blob/123dcd96595bbe20dfc2634659fac5b451517bda/src/JET.jl#L336-L346">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../config/">« Configurations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 13 March 2021 12:33">Saturday 13 March 2021</span>. Using Julia version 1.7.0-DEV.705.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
